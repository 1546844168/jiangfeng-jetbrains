<application>
  <component name="AppStorage">
    <histories>
      <item value="Annotation to activate Eureka Server related configuration" />
      <item value="Spring Expression Language (SpEL) expression used to veto method caching. * &lt;p&gt;Unlike {@link #condition}, this expression is evaluated after the method * has been called and can therefore refer to the {@code result}. * &lt;p&gt;Default is {@code &quot;&quot;}, meaning that caching is never vetoed. * &lt;p&gt;The SpEL expression evaluates against a dedicated context that provides the * following meta-data: * &lt;ul&gt; * &lt;li&gt;{@code #result} for a reference to the result of the method invocation. For * supported wrappers such as {@code Optional}, {@code #result} refers to the actual * object, not the wrapper&lt;/li&gt; * &lt;li&gt;{@code #root.method}, {@code #root.target}, and {@code #root.caches} for * references to the {@link java.lang.reflect.Method method}, target object, and * affected cache(s) respectively.&lt;/li&gt; * &lt;li&gt;Shortcuts for the method name ({@code #root.methodName}) and target class * ({@code #root.targetClass}) are also available. * &lt;li&gt;Method arguments can be accessed by index. For instance the second argument * can be accessed via {@code #root.args[1]}, {@code #p1} or {@code #a1}. Arguments * can also be accessed by name if that information is available.&lt;/li&gt; * &lt;/ul&gt;" />
      <item value="The bean name of the custom {@link org.springframework.cache.interceptor.KeyGenerator} * to use. * &lt;p&gt;Mutually exclusive with the {@link #key} attribute." />
      <item value="Names of the caches in which method invocation results are stored." />
      <item value="caching behavior will be applied" />
      <item value="&gt;Each time an advised method is invoked," />
      <item value="indicating" />
      <item value="Alias for the {@link #basePackages()} attribute. Allows for more concise annotation declarations e.g.: * {@code @MapperScan(&quot;org.my.pkg&quot;)} instead of {@code @MapperScan(basePackages = &quot;org.my.pkg&quot;})}." />
      <item value="delegates" />
      <item value="Exceptions handled by the annotated method. If empty, will default to any * exceptions listed in the method argument list." />
      <item value="Return the list of statically specified ApplicationListeners." />
      <item value="拓展" />
      <item value="execution" />
      <item value="事务" />
      <item value="Note that this name is the actual bean name used in the factory, which may * differ from the originally specified name: in particular for inner bean * names, the actual bean name might have been made unique through appending * &quot;#...&quot; suffixes. Use the {@link BeanFactoryUtils#originalBeanName(String)} * method to extract the original bean name (without suffix), if desired." />
      <item value="Set the name of the bean in the bean factory that created this bean. * &lt;p&gt;Invoked after population of normal bean properties but before an * init callback such as {@link InitializingBean#afterPropertiesSet()} * or a custom init-method." />
      <item value="* * Return an instance (possibly shared or independent) of the object * managed by this factory. * &lt;p&gt;As with a {@link BeanFactory}, this allows support for both the * Singleton and Prototype design pattern. * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of * the call (for example because it is involved in a circular reference), * throw a corresponding {@link FactoryBeanNotInitializedException}. * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null} * objects. The factory will consider this as normal value to be used; it * will not throw a FactoryBeanNotInitializedException in this case anymore. * FactoryBean implementations are encouraged to throw * FactoryBeanNotInitializedException themselves now, as appropriate. * @return an instance of the bean (can be {@code null}) * @throws Exception in case of creation errors * @see FactoryBeanNotInitializedException" />
      <item value="Standalone application context, accepting annotated classes as input - in particular" />
      <item value="Import Selector" />
      <item value="* Register bean definitions as necessary based on the given annotation metadata of * the importing {@code @Configuration} class. * &lt;p&gt;Note that {@link BeanDefinitionRegistryPostProcessor} types may &lt;em&gt;not&lt;/em&gt; be * registered here, due to lifecycle constraints related to {@code @Configuration} * class processing. * @param importingClassMetadata annotation metadata of the importing class * @param registry current bean definition registry */" />
      <item value="Select and return the names of which class(es) should be imported based on * the {@link AnnotationMetadata} of the importing @{@link Configuration} class. */" />
      <item value="equivalent" />
      <item value="Illegal State Exception" />
      <item value="superfluous" />
      <item value="redundant" />
      <item value="a factory for obtaining metadata readers * for other classes (such as superclasses and interfaces)" />
      <item value="the metadata reader for the target class" />
      <item value="ASSIGNABLE TYPE" />
      <item value="Determine whether this filter matches for the class described by * the given metadata." />
      <item value="Filter candidates using a given custom" />
      <item value="Filter candidates assignable to a given type" />
      <item value="* Filter candidates marked with a given annotation." />
      <item value="Specify whether scanned beans should be registered for lazy initialization." />
      <item value="The class or classes to use as the filter. * &lt;p&gt;The following table explains how the classes will be interpreted * based on the configured value of the {@link #type} attribute. * &lt;table border=&quot;1&quot;&gt; * &lt;tr&gt;&lt;th&gt;{@code FilterType}&lt;/th&gt;&lt;th&gt;Class Interpreted As&lt;/th&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;{@link FilterType#ANNOTATION ANNOTATION}&lt;/td&gt; * &lt;td&gt;the annotation itself&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;{@link FilterType#ASSIGNABLE_TYPE ASSIGNABLE_TYPE}&lt;/td&gt; * &lt;td&gt;the type that detected components should be assignable to&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;{@link FilterType#CUSTOM CUSTOM}&lt;/td&gt; * &lt;td&gt;an implementation of {@link TypeFilter}&lt;/td&gt;&lt;/tr&gt; * &lt;/table&gt; * &lt;p&gt;When multiple classes are specified, &lt;em&gt;OR&lt;/em&gt; logic is applied * &amp;mdash; for example, &quot;include types annotated with {@code @Foo} OR {@code @Bar}&quot;. * &lt;p&gt;Custom {@link TypeFilter TypeFilters} may optionally implement any of the * following {@link org.springframework.beans.factory.Aware Aware} interfaces, and * their respective methods will be called prior to {@link TypeFilter#match match}: * &lt;ul&gt; * &lt;li&gt;{@link org.springframework.context.EnvironmentAware EnvironmentAware}&lt;/li&gt; * &lt;li&gt;{@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware} * &lt;li&gt;{@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware} * &lt;li&gt;{@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware} * &lt;/ul&gt; * &lt;p&gt;Specifying zero classes is permitted but will have no effect on component * scanning. * @since 4.2 * @see #value * @see #type" />
      <item value="value" />
      <item value="resource Pattern" />
      <item value="scoped Proxy" />
      <item value="Indicates whether automatic detection of classes annotated with {@code @Component} * {@code @Repository}, {@code @Service}, or {@code @Controller} should be enabled." />
      <item value="Controls the class files eligible for component detection. * &lt;p&gt;Consider use of {@link #includeFilters} and {@link #excludeFilters} * for a more flexible approach." />
      <item value="Specifies which types are not eligible for component scanning." />
      <item value="Note: You may use placeholders in package paths, but only resolved against system properties (analogous to resource paths). A component scan results in new bean definitions being registered; Spring's PropertySourcesPlaceholderConfigurer will apply to those bean definitions just like to regular bean definitions, but it won't apply to the component scan settings themselves." />
      <item value="Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations." />
      <item value="external" />
      <item value="activating" />
      <item value="implies" />
      <item value="Scans the classpath for annotated components that will be auto-registered as Spring beans. By default, the Spring-provided @Component, @Repository, @Service, @Controller, @RestController, @ControllerAdvice, and @Configuration stereotypes will be detected." />
      <item value="Rest Controller" />
      <item value="Description : A set of build extensions to use from this project." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="34" />
        <entry key="ENGLISH" value="35" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>