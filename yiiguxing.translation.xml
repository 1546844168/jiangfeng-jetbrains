<application>
  <component name="AppStorage">
    <histories>
      <item value="Parameter index out of range (2 &gt; number of parameters, which is 1)" />
      <item value="自定义款支付状态" />
      <item value="自定义款" />
      <item value="异常款支付状态" />
      <item value="Equivalent" />
      <item value="ORDINARY" />
      <item value="dubbo" />
      <item value="absent" />
      <item value="Executes the given task sometime in the future. The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current {@code RejectedExecutionHandler}." />
      <item value="approximation" />
      <item value="Returns the amount of free memory in the Java Virtual Machine. * Calling the * &lt;code&gt;gc&lt;/code&gt; method may result in increasing the value returned * by &lt;code&gt;freeMemory.&lt;/code&gt; * * @return an approximation to the total amount of memory currently * available for future allocated objects, measured in bytes." />
      <item value="widget" />
      <item value="widget Key" />
      <item value="Sorts the specified range of the array using the given * workspace array slice if possible for merging" />
      <item value="the estimated number of concurrently * updating threads. The implementation may use this value as" />
      <item value="Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table." />
      <item value="only If Absent" />
      <item value="Returns a power of two size for the given target capacity." />
      <item value="Resizable-array implementation of the &lt;tt&gt;List&lt;/tt&gt; interface. Implements * all optional list operations, and permits all elements, including * &lt;tt&gt;null&lt;/tt&gt;. In addition to implementing the &lt;tt&gt;List&lt;/tt&gt; interface, * this class provides methods to manipulate the size of the array that is * used internally to store the list. (This class is roughly equivalent to * &lt;tt&gt;Vector&lt;/tt&gt;, except that it is unsynchronized.) * * &lt;p&gt;The &lt;tt&gt;size&lt;/tt&gt;, &lt;tt&gt;isEmpty&lt;/tt&gt;, &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;, * &lt;tt&gt;iterator&lt;/tt&gt;, and &lt;tt&gt;listIterator&lt;/tt&gt; operations run in constant * time. The &lt;tt&gt;add&lt;/tt&gt; operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;, * that is, adding n elements requires O(n) time. All of the other operations * run in linear time (roughly speaking). The constant factor is low compared * to that for the &lt;tt&gt;LinkedList&lt;/tt&gt; implementation. * * &lt;p&gt;Each &lt;tt&gt;ArrayList&lt;/tt&gt; instance has a &lt;i&gt;capacity&lt;/i&gt;. The capacity is * the size of the array used to store the elements in the list. It is always * at least as large as the list size. As elements are added to an ArrayList, * its capacity grows automatically. The details of the growth policy are not * specified beyond the fact that adding an element has constant amortized * time cost. * * &lt;p&gt;An application can increase the capacity of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance * before adding a large number of elements using the &lt;tt&gt;ensureCapacity&lt;/tt&gt; * operation. This may reduce the amount of incremental reallocation. * * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; * If multiple threads access an &lt;tt&gt;ArrayList&lt;/tt&gt; instance concurrently, * and at least one of the threads modifies the list structurally, it * &lt;i&gt;must&lt;/i&gt; be synchronized externally. (A structural modification is * any operation that adds or deletes one or more elements, or explicitly * resizes the backing array; merely setting the value of an element is not * a structural modification.) This is typically accomplished by * synchronizing on some object that naturally encapsulates the list. * * If no such object exists, the list should be &quot;wrapped&quot; using the * {@link Collections#synchronizedList Collections.synchronizedList} * method. This is best done at creation time, to prevent accidental * unsynchronized access to the list:&lt;pre&gt; * List list = Collections.synchronizedList(new ArrayList(...));&lt;/pre&gt; * * &lt;p&gt;&lt;a name=&quot;fail-fast&quot;&gt; * The iterators returned by this class's {@link #iterator() iterator} and * {@link #listIterator(int) listIterator} methods are &lt;em&gt;fail-fast&lt;/em&gt;:&lt;/a&gt; * if the list is structurally modified at any time after the iterator is * created, in any way except through the iterator's own * {@link ListIterator#remove() remove} or * {@link ListIterator#add(Object) add} methods, the iterator will throw a * {@link ConcurrentModificationException}. Thus, in the face of * concurrent modification, the iterator fails quickly and cleanly, rather * than risking arbitrary, non-deterministic behavior at an undetermined * time in the future. * * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed * as it is, generally speaking, impossible to make any hard guarantees in the * presence of unsynchronized concurrent modification. Fail-fast iterators * throw {@code ConcurrentModificationException} on a best-effort basis. * Therefore, it would be wrong to write a program that depended on this * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators * should be used only to detect bugs.&lt;/i&gt; * * &lt;p&gt;This class is a member of the * &lt;a href=&quot;{@docRoot}/../technotes/guides/collections/index.html&quot;&gt; * Java Collections Framework&lt;/a&gt;." />
      <item value="Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument." />
      <item value="ensure Capacity Internal" />
      <item value="MILLISECONDS" />
      <item value="MICROSECONDS" />
      <item value="eliminate obsolete reference" />
      <item value="a copy of the original array, truncated or padded with nulls * to obtain the specified length" />
      <item value="Copies the specified array, truncating or padding with nulls (if necessary) * so the copy has the specified length. For all indices that are * valid in both the original array and the copy, the two arrays will * contain identical values. For any indices that are valid in the * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;. * Such indices will exist if and only if the specified length * is greater than that of the original array. * The resulting array is of exactly the same class as the original array." />
      <item value="expected alphabetic or numeric character" />
      <item value="eviction" />
      <item value="authority" />
      <item value="Annotation to activate Eureka Server related configuration" />
      <item value="Spring Expression Language (SpEL) expression used to veto method caching. * &lt;p&gt;Unlike {@link #condition}, this expression is evaluated after the method * has been called and can therefore refer to the {@code result}. * &lt;p&gt;Default is {@code &quot;&quot;}, meaning that caching is never vetoed. * &lt;p&gt;The SpEL expression evaluates against a dedicated context that provides the * following meta-data: * &lt;ul&gt; * &lt;li&gt;{@code #result} for a reference to the result of the method invocation. For * supported wrappers such as {@code Optional}, {@code #result} refers to the actual * object, not the wrapper&lt;/li&gt; * &lt;li&gt;{@code #root.method}, {@code #root.target}, and {@code #root.caches} for * references to the {@link java.lang.reflect.Method method}, target object, and * affected cache(s) respectively.&lt;/li&gt; * &lt;li&gt;Shortcuts for the method name ({@code #root.methodName}) and target class * ({@code #root.targetClass}) are also available. * &lt;li&gt;Method arguments can be accessed by index. For instance the second argument * can be accessed via {@code #root.args[1]}, {@code #p1} or {@code #a1}. Arguments * can also be accessed by name if that information is available.&lt;/li&gt; * &lt;/ul&gt;" />
      <item value="The bean name of the custom {@link org.springframework.cache.interceptor.KeyGenerator} * to use. * &lt;p&gt;Mutually exclusive with the {@link #key} attribute." />
      <item value="Names of the caches in which method invocation results are stored." />
      <item value="caching behavior will be applied" />
      <item value="&gt;Each time an advised method is invoked," />
      <item value="indicating" />
      <item value="Alias for the {@link #basePackages()} attribute. Allows for more concise annotation declarations e.g.: * {@code @MapperScan(&quot;org.my.pkg&quot;)} instead of {@code @MapperScan(basePackages = &quot;org.my.pkg&quot;})}." />
      <item value="delegates" />
      <item value="Exceptions handled by the annotated method. If empty, will default to any * exceptions listed in the method argument list." />
      <item value="Return the list of statically specified ApplicationListeners." />
      <item value="拓展" />
      <item value="execution" />
      <item value="事务" />
      <item value="Note that this name is the actual bean name used in the factory, which may * differ from the originally specified name: in particular for inner bean * names, the actual bean name might have been made unique through appending * &quot;#...&quot; suffixes. Use the {@link BeanFactoryUtils#originalBeanName(String)} * method to extract the original bean name (without suffix), if desired." />
      <item value="Set the name of the bean in the bean factory that created this bean. * &lt;p&gt;Invoked after population of normal bean properties but before an * init callback such as {@link InitializingBean#afterPropertiesSet()} * or a custom init-method." />
      <item value="* * Return an instance (possibly shared or independent) of the object * managed by this factory. * &lt;p&gt;As with a {@link BeanFactory}, this allows support for both the * Singleton and Prototype design pattern. * &lt;p&gt;If this FactoryBean is not fully initialized yet at the time of * the call (for example because it is involved in a circular reference), * throw a corresponding {@link FactoryBeanNotInitializedException}. * &lt;p&gt;As of Spring 2.0, FactoryBeans are allowed to return {@code null} * objects. The factory will consider this as normal value to be used; it * will not throw a FactoryBeanNotInitializedException in this case anymore. * FactoryBean implementations are encouraged to throw * FactoryBeanNotInitializedException themselves now, as appropriate. * @return an instance of the bean (can be {@code null}) * @throws Exception in case of creation errors * @see FactoryBeanNotInitializedException" />
      <item value="Standalone application context, accepting annotated classes as input - in particular" />
      <item value="Import Selector" />
      <item value="* Register bean definitions as necessary based on the given annotation metadata of * the importing {@code @Configuration} class. * &lt;p&gt;Note that {@link BeanDefinitionRegistryPostProcessor} types may &lt;em&gt;not&lt;/em&gt; be * registered here, due to lifecycle constraints related to {@code @Configuration} * class processing. * @param importingClassMetadata annotation metadata of the importing class * @param registry current bean definition registry */" />
      <item value="Select and return the names of which class(es) should be imported based on * the {@link AnnotationMetadata} of the importing @{@link Configuration} class. */" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="62" />
        <entry key="ENGLISH" value="63" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>